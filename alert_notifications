import sqlite3
import smtplib
import json
import threading
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from email.message import EmailMessage
from typing import Optional, List

# Database for stock and alerts
class InventoryDB:
    def __init__(self, path: str = ":memory:"):
        self.conn = sqlite3.connect(path, check_same_thread=False)
        self._init()
        self._lock = threading.Lock()

    def _init(self):
        cur = self.conn.cursor()
        cur.execute("""
            CREATE TABLE IF NOT EXISTS inventory (
                sku TEXT PRIMARY KEY,
                name TEXT,
                qty INTEGER,
                avg_daily_usage REAL,
                lead_time_days INTEGER,
                min_threshold INTEGER DEFAULT 0,
                max_threshold INTEGER DEFAULT 0,
                prefs TEXT DEFAULT '{}'
            )
        """)
        cur.execute("""
            CREATE TABLE IF NOT EXISTS alerts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                sku TEXT,
                level TEXT,
                message TEXT,
                timestamp TEXT,
                resolved INTEGER DEFAULT 0
            )
        """)
        self.conn.commit()

    def upsert_item(self, sku, name, qty, avg_daily_usage=0.0, lead_time_days=7,
                    min_threshold=0, max_threshold=0, prefs=None):
        prefs_json = json.dumps(prefs or {})
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("""
                INSERT INTO inventory (sku,name,qty,avg_daily_usage,lead_time_days,
                    min_threshold,max_threshold,prefs)
                VALUES (?,?,?,?,?,?,?,?)
                ON CONFLICT(sku) DO UPDATE SET
                    name=excluded.name,
                    qty=excluded.qty,
                    avg_daily_usage=excluded.avg_daily_usage,
                    lead_time_days=excluded.lead_time_days,
                    min_threshold=excluded.min_threshold,
                    max_threshold=excluded.max_threshold,
                    prefs=excluded.prefs
            """, (sku, name, qty, avg_daily_usage, lead_time_days,
                  min_threshold, max_threshold, prefs_json))
            self.conn.commit()

    def update_qty(self, sku, qty):
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("UPDATE inventory SET qty=? WHERE sku=?", (qty, sku))
            self.conn.commit()

    def get_all_items(self):
        cur = self.conn.cursor()
        cur.execute("SELECT sku,name,qty,avg_daily_usage,lead_time_days,min_threshold,max_threshold,prefs FROM inventory")
        rows = cur.fetchall()
        items = []
        for r in rows:
            items.append({
                'sku': r[0], 'name': r[1], 'qty': r[2],
                'avg_daily_usage': r[3], 'lead_time_days': r[4],
                'min_threshold': r[5], 'max_threshold': r[6],
                'prefs': json.loads(r[7] or '{}')
            })
        return items

    def log_alert(self, sku, level, message):
        ts = datetime.utcnow().isoformat()
        with self._lock:
            cur = self.conn.cursor()
            cur.execute("INSERT INTO alerts (sku,level,message,timestamp) VALUES (?,?,?,?)",
                        (sku, level, message, ts))
            self.conn.commit()

    def get_recent_alerts(self, sku, minutes=60):
        cutoff = (datetime.utcnow() - timedelta(minutes=minutes)).isoformat()
        cur = self.conn.cursor()
        cur.execute("SELECT id,sku,level,message,timestamp,resolved FROM alerts WHERE sku=? AND timestamp>=? ORDER BY timestamp DESC",
                    (sku, cutoff))
        rows = cur.fetchall()
        return [{'id': r[0], 'sku': r[1], 'level': r[2], 'message': r[3],
                 'timestamp': r[4], 'resolved': bool(r[5])} for r in rows]

# Notifications
@dataclass
class NotifierConfig:
    smtp_server: Optional[str] = None
    smtp_port: int = 587
    smtp_user: Optional[str] = None
    smtp_password: Optional[str] = None
    from_email: Optional[str] = None
    webhook_url: Optional[str] = None
    suppress_quiet_hours: bool = True

class Notifier:
    def __init__(self, cfg: NotifierConfig):
        self.cfg = cfg

    def send_console(self, subject, message):
        print(f"[NOTIFY] {datetime.utcnow().isoformat()} - {subject}: {message}")

    def send_email(self, to_email, subject, body):
        if not self.cfg.smtp_server or not self.cfg.from_email:
            return self.send_console(subject, body)
        msg = EmailMessage()
        msg['From'] = self.cfg.from_email
        msg['To'] = to_email
        msg['Subject'] = subject
        msg.set_content(body)
        try:
            with smtplib.SMTP(self.cfg.smtp_server, self.cfg.smtp_port, timeout=10) as smtp:
                smtp.starttls()
                if self.cfg.smtp_user and self.cfg.smtp_password:
                    smtp.login(self.cfg.smtp_user, self.cfg.smtp_password)
                smtp.send_message(msg)
        except Exception as e:
            print(f"[WARN] Email send failed: {e}")
            self.send_console(subject, body)

    def send_webhook(self, subject, body):
        if not self.cfg.webhook_url:
            return self.send_console(subject, body)
        try:
            import requests
            requests.post(self.cfg.webhook_url,
                          json={'subject': subject, 'body': body}, timeout=5)
        except Exception as e:
            print(f"[WARN] Webhook failed: {e}")
            self.send_console(subject, body)

# Alert preferences
@dataclass
class AlertPreferences:
    quiet_hours_start: Optional[int] = None
    quiet_hours_end: Optional[int] = None
    coalesce_minutes: int = 60
    escalation_window_days: int = 3
    notify_emails: List[str] = field(default_factory=list)

# Alert logic
class AlertEngine:
    def __init__(self, db: InventoryDB, notifier: Notifier,
                 global_prefs: Optional[AlertPreferences] = None):
        self.db = db
        self.notifier = notifier
        self.global_prefs = global_prefs or AlertPreferences()

    def compute_reorder_point(self, avg_daily_usage, lead_time_days, safety_days=2):
        return max(1, int(round(avg_daily_usage * (lead_time_days + safety_days))))

    def determine_level(self, qty, min_threshold, rop):
        if qty <= 0:
            return 'CRITICAL'
        if qty <= min_threshold:
            return 'CRITICAL' if qty < min_threshold // 2 else 'WARNING'
        if qty <= rop:
            return 'WARNING'
        return 'INFO'

    def should_notify(self, sku, level, prefs: AlertPreferences):
        recent = self.db.get_recent_alerts(sku, minutes=prefs.coalesce_minutes)
        if recent and recent[0]['level'] == level:
            return False
        if prefs.quiet_hours_start is not None and prefs.quiet_hours_end is not None and not self.global_prefs.suppress_quiet_hours:
            h = datetime.utcnow().hour
            s, e = prefs.quiet_hours_start, prefs.quiet_hours_end
            in_quiet = (s <= h < e) if s <= e else (h >= s or h < e)
            if in_quiet and level != 'CRITICAL':
                return False
        return True

    def escalate_if_needed(self, sku, level, message):
        alerts = self.db.get_recent_alerts(sku, minutes=60*24*self.global_prefs.escalation_window_days)
        critical_count = sum(1 for a in alerts if a['level'] == 'CRITICAL')
        if critical_count >= 2 and level == 'CRITICAL':
            self.notifier.send_console(f"ESCALATION for {sku}",
                                       f"{message} (critical_count={critical_count})")

    def check_item(self, item, item_prefs=None):
        sku, name, qty = item['sku'], item['name'], int(item['qty'])
        avg_daily = float(item.get('avg_daily_usage') or 0)
        lead_time = int(item.get('lead_time_days') or 7)
        min_threshold = int(item.get('min_threshold') or 0)

        prefs = AlertPreferences(**self.global_prefs.__dict__)
        if item_prefs:
            for k, v in item_prefs.items():
                if hasattr(prefs, k):
                    setattr(prefs, k, v)

        rop = self.compute_reorder_point(avg_daily, lead_time)
        level = self.determine_level(qty, min_threshold, rop)
        message = f"{name} (SKU:{sku}) qty={qty} | ROP={rop}"

        if level == 'INFO':
            return {'sku': sku, 'level': level, 'message': message, 'actioned': False}

        if not self.should_notify(sku, level, prefs):
            return {'sku': sku, 'level': level, 'message': message, 'actioned': False}

        self.db.log_alert(sku, level, message)

        subject = f"{level} stock alert: {name}"
        body = message + "\n" + self.suggest_action(qty, rop)

        self.notifier.send_console(subject, body)
        for em in prefs.notify_emails:
            self.notifier.send_email(em, subject, body)
        self.notifier.send_webhook(subject, body)

        self.escalate_if_needed(sku, level, message)

        return {'sku': sku, 'level': level, 'message': message, 'actioned': True}

    def suggest_action(self, qty, rop):
        if qty <= 0:
            return 'Order immediately - out of stock.'
        if qty < rop:
            return f'Place order for at least {(rop - qty)} units.'
        return 'Stock is fine.'

    def check_all_items(self):
        results = []
        for item in self.db.get_all_items():
            prefs = item.get('prefs') or {}
            results.append(self.check_item(item, item_prefs=prefs))
        return results

# Demo
DEMO_DATA = [
    {'sku': 'ABC123', 'name': 'Widget Small', 'qty': 3,
     'avg_daily_usage': 1.2, 'lead_time_days': 5, 'min_threshold': 2,
     'prefs': {'notify_emails': ['manager@example.com'], 'coalesce_minutes': 120}},
    {'sku': 'XYZ999', 'name': 'Gadget Large', 'qty': 50,
     'avg_daily_usage': 0.5, 'lead_time_days': 14, 'min_threshold': 10,
     'prefs': {}},
    {'sku': 'EMPTY01', 'name': 'Broken Part', 'qty': 0,
     'avg_daily_usage': 0.1, 'lead_time_days': 7, 'min_threshold': 1}
]

def demo_run():
    db = InventoryDB('stock_alerts.db')
    for it in DEMO_DATA:
        db.upsert_item(it['sku'], it['name'], it['qty'],
                       it['avg_daily_usage'], it['lead_time_days'],
                       it.get('min_threshold', 0), 0, it.get('prefs'))

    notifier = Notifier(NotifierConfig())
    global_prefs = AlertPreferences(notify_emails=['ops@example.com'])
    engine = AlertEngine(db, notifier, global_prefs)

    print('Running checks...')
    results = engine.check_all_items()
    for r in results:
        print(' ->', r)

    print('\nAlert history:')
    cur = db.conn.cursor()
    for row in cur.execute('SELECT id,sku,level,message,timestamp FROM alerts ORDER BY id DESC'):
        print(row)

if __name__ == '__main__':
    import sys
    if len(sys.argv) > 1 and sys.argv[1] == 'demo':
        demo_run()
    else:
        print('Run with: python stock_alert_system.py demo')
